import { AbstractInputGenerator } from "./AbstractInputGenerator";
import { ArgType, ArgValueType } from "../analysis/typescript/Types";
import { ArgDef } from "../analysis/typescript/ArgDef";
import { AbstractMeasure } from "../measures/AbstractMeasure";
import { BaseMeasurement } from "../measures/Types";

// !!!!
export class CompositeInputGenerator extends AbstractInputGenerator {
  private _subgens: AbstractInputGenerator[]; // Subordinate input generators
  private _tick = 0; // Number of inputs generated
  private _ticksLeftInChunk = 0; // Number of input generations remaining in this chunk
  private _measures: AbstractMeasure[]; // Measures that provide feedback
  private _weights: number[]; // Weights for the various measures
  private _history: {
    values: (number | undefined)[][];
    currentIndex: number;
  }[]; // !!!!!!
  private _injectedInputs: ArgValueType[][] = []; // Inputs to force generate first
  private _selectedSubgenIndex = 0; // Selected subordinate input generator (e.g., by efficiency)
  private readonly _L = 10; // Lookback window size for history.
  private readonly _chunkSize = 1; // Re-evaluate subgen after _chunkSize inputs generated
  private readonly _explorationP = 20; // Exploration probability.
  public static readonly INJECTED = "injected";

  // !!!!!!
  public constructor(
    argType: ArgDef<ArgType>[],
    rngSeed: string,
    subgens: AbstractInputGenerator[],
    measures: AbstractMeasure[]
  ) {
    super(argType, rngSeed);

    this._subgens = subgens;
    this._measures = measures;
    this._weights = measures.map((m) => m.weight);

    if (this._subgens.length === 0)
      throw new Error(
        "No input generators provided to CompositeInputGenerator."
      );

    // Initialize measure history
    this._history = subgens.map(() => ({
      values: measures.map(() => Array(this._L).fill(undefined)),
      currentIndex: 0,
    }));
  }

  // !!!!!!
  public inject(inputs: ArgValueType[][]): void {
    this._injectedInputs = inputs.reverse();
  }

  // !!!!!!
  public next(): { input: ArgValueType[]; source: string } {
    this._tick++;

    // Produce injected inputs first, if available
    if (this._injectedInputs.length) {
      const injectedInput = this._injectedInputs.pop();
      if (injectedInput) {
        return {
          input: injectedInput,
          source: CompositeInputGenerator.INJECTED,
        };
      }
    }

    // If the prior chunk of generated inputs is exhausted, start
    // a new chunk and re-determine subgen efficiency
    if (this._ticksLeftInChunk < 1) {
      this._ticksLeftInChunk = this._chunkSize;
      const [nextSubGen, reason] = this.selectNextSubGen();
      if (nextSubGen !== this._selectedSubgenIndex) {
        console.debug(
          `[${this.name}][${this._tick}] Switching subgen from "${
            this._subgens[this._selectedSubgenIndex].name
          }" to "${this._subgens[nextSubGen].name}" b/c "${reason}`
        ); // !!!!!!!
      }
      this._selectedSubgenIndex = nextSubGen;
    }
    this._ticksLeftInChunk--;

    // Randomly select a subgen 1 in P times, otherwise use the most
    // efficient subgen
    let gen: AbstractInputGenerator;
    const rand = Math.floor(this._prng() * this._explorationP);
    const G = this._subgens.length;
    if (rand === 0) {
      const randval = Math.floor(this._prng() * G);
      gen = this._subgens[randval]; // random subgen (exploration)
    } else {
      gen = this._subgens[this._selectedSubgenIndex]; // most efficient subgen
    }

    // Return the input generated by the subgen
    return gen.next(); // TODO Track execution cost here !!!!
  }

  // !!!!!!
  public onInputFeedback(measurements: BaseMeasurement[]): void {
    // Ensure we have a matching number of measures
    if (measurements.length !== this._measures.length) {
      throw new Error(
        `Number of feedback measures (${measurements.length}) differs from number of expected measures (${this._measures.length})`
      );
    }

    // Add each of the measurements to the history
    let m: keyof typeof this._measures;
    for (m in this._measures) {
      const h = this._history[this._selectedSubgenIndex]; // history of current subgen
      const measure = this._measures[m]; // current measure
      const measurement = measurements[m]; // input measurement for current measure

      // Fail if we receive a different measurement than expected
      if (measure.name !== measurement.name) {
        throw new Error(
          `Expected feedback for measure "${measure.name}" at offset ${String(
            m
          )} but received "${measurement.name}" instead.`
        );
      }

      // Update history
      h.values[m][h.currentIndex] = measurement.value;
      h.currentIndex = (h.currentIndex + 1) % this._L;
    }
  }

  // !!!!!!
  private selectNextSubGen(): [number, "efficiency" | "explore"] {
    const G = this._subgens.length;
    if (
      this._tick === 0 ||
      Math.floor(this._prng() * this._explorationP) === 0
    ) {
      // Exploration on first run or with prob 1/_explorationP.
      return [Math.floor(this._prng() * G), "explore"];
    } else {
      // Pick g with max weighted sum of delta-M over last L runs with g as selected generator.
      let bestIdx = 0;
      let bestEff = -Infinity;
      for (let genIdx = 0; genIdx < G; genIdx++) {
        let sum = 0;
        for (
          let measureIdx = 0;
          measureIdx < this._measures.length;
          measureIdx++
        ) {
          const buffer = this._history[genIdx].values[measureIdx];

          for (let i = 1; i < this._L; i++) {
            const current = buffer[i];
            const previous = buffer[i - 1];
            if (current !== undefined && previous !== undefined) {
              sum += (current - previous) * this._weights[measureIdx];
            }
          }
          const eff = sum / 1; // TODO: Let us set cost=1 for now.
          if (eff > bestEff) {
            bestEff = eff;
            bestIdx = genIdx;
          }
        }
      }
      return [bestIdx, "efficiency"];
    }
  }
}
